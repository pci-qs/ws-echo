// Generated by CoffeeScript 1.7.1
(function() {
  var CORSify, WebSocketServer, express, http, log, logError, on_request, pkg, websocket;

  http = require("http");

  express = require("express");

  websocket = require("websocket");
  
  const crypto = require('crypto');

  WebSocketServer = websocket.server;

  pkg = require("../package.json");

  exports.main = function() {
    var app, port, server, wsServer;
    if (process.env.PORT == null) {
      logError("PORT environment variable not set");
    }
    port = parseInt(process.env.PORT);
    if (isNaN(port)) {
      logError("invalid PORT environment variable: " + process.env.PORT);
    }
    app = express();
    app.use(express["static"]("www"));
    server = http.createServer(app);
    
    wsServer = new WebSocketServer({
      httpServer: server
    });
    
    server.on('upgrade', function (req, socket) {
      log('req: ' + req.httpVersion);
      if (req.headers['upgrade'] !== 'websocket') {
        socket.end('HTTP/1.1 400 Bad Request');
        return;
      }
      if (req.headers['sec-websocket-version'] === '13'){
        return;
      }
      // Read the websocket key provided by the client: 
      const acceptKey = req.headers['sec-websocket-key']; 
      // Generate the response value to use in the response: 
      const hash = generateAcceptValue(acceptKey); 
      // Write the HTTP response into an array of response lines: 
      const responseHeaders = [ 'HTTP/1.1 101 Web Socket Protocol Handshake', 'Upgrade: WebSocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${hash}` ]; 
      log('Hash: ' + hash);
      log('response hearders: ' + responseHeaders);
      // Write the response back to the client socket, being sure to append two 
      // additional newlines so that the browser recognises the end of the response 
      // header and doesn't continue to wait for more header data: 
      socket.write(responseHeaders.join('\r\n') + '\r\n\r\n');
    });
     // Don't forget the hashing function described earlier:
    function generateAcceptValue (acceptKey) {
      return crypto
      .createHash('sha1')
      .update(acceptKey + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', 'binary')
      .digest('base64');
    }
    
    
    server.listen(port, function() {
      return log("server started: http://localhost:" + port);
    });
    
    return wsServer.on("request", function(request) {
      return on_request(request);
    });
  };

  on_request = function(request) {
    var connection;
    log("connection from origin: " + request.origin);
    connection = request.accept(null, request.origin);
    connection.sendUTF("Connected");  
    connection.on("message", function(message) {
      if (message.type === "utf8") {
        log("received message: " + message.utf8Data);
        return connection.sendUTF(message.utf8Data);
      } else if (message.type === "binary") {
        log("received binary message of " + message.binaryData.length + " bytes");
        return connection.sendBytes(message.binaryData);
      }
    });
    return connection.on("close", function(reasonCode, description) {
      return log("peer " + connection.remoteAddress + " disconnected.");
    });
  };

  log = function(message) {
    return console.log("" + pkg.name + ": " + message);
  };

  logError = function(message) {
    log(message);
    return process.exit(1);
  };

  CORSify = function(request, response, next) {
    response.header("Access-Control-Allow-Origin:", "*");
    response.header("Access-Control-Allow-Methods", "POST, GET,");
    return next();
  };

}).call(this);
